use std::{
    collections::{HashMap, HashSet},
    str::FromStr,
};

use crate::ast::{self, Statement};

// #[derive(Debug)]
// pub struct FunctionID(usize);
//
// #[derive(Debug)]
// pub struct ModuleID(usize);

// #[derive(Debug)]
// pub struct TypeID(usize);

// #[derive(Debug, Default)]
// pub struct Module {
//     pub functions: Vec<Function>,
//     pub function_map: HashMap<String, FunctionID>,
//     pub composite_types: Vec<Type>,
// }

// #[derive(Debug)]
// pub enum Type {
//     Primitive(Primitive),
//     Struct(Vec<(String, TypeID)>),
//     Union(Vec<(String, TypeID)>),
//     Pointer(TypeID),
// }

#[derive(Debug)]
pub enum Primitive {
    I8,
    I16,
    I32,
    I64,
    I128,
    U8,
    U16,
    U32,
    U64,
    U128,
    F32,
    F64,
}

impl FromStr for Primitive {
    type Err = SemanticError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "i8" => Ok(Self::I8),
            "i16" => Ok(Self::I16),
            "i32" => Ok(Self::I32),
            "i64" => Ok(Self::I64),
            "i128" => Ok(Self::I128),
            "u8" => Ok(Self::U8),
            "u16" => Ok(Self::U16),
            "u32" => Ok(Self::U32),
            "u64" => Ok(Self::U64),
            "u128" => Ok(Self::U128),
            "f32" => Ok(Self::F32),
            "f64" => Ok(Self::F64),
            _ => Err(SemanticError::UnexpectedIdentifier(s.to_string())),
        }
    }
}

#[derive(Debug)]
pub struct FunctionParam {
    name: String,
    datatype: Primitive,
}

#[derive(Debug)]
pub enum Function {
    // Extern {
    //     name: String,
    //     params: Vec<FunctionParam>,
    //     calling_convention: String,
    // },
    Local {
        name: String,
        params: Vec<FunctionParam>,
        return_type: Option<Primitive>,
        body: Vec<Statement>,
    },
}

#[derive(Debug)]
pub struct Program {
    pub functions: HashMap<String, Function>,
}

impl Program {
    pub fn new(module: &ast::Module) -> Result<Self, SemanticError> {
        let mut functions = HashMap::new();

        for function_def in &module.function_definitions {
            let return_type = match &function_def.return_type {
                Some(t) => Some(t.parse::<Primitive>()?),
                None => None,
            };
            let f = Function::Local {
                name: function_def.name.clone(),
                params: Vec::new(),
                body: function_def.body.clone(),
                return_type,
            };
            functions.insert(function_def.name.to_string(), f);
        }

        Ok(Self { functions })
    }
}

#[derive(Debug)]
pub enum SemanticError {
    UnexpectedIdentifier(String),
}
